<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <title>Ответы на теоретические вопросы. 30 неделя. "MobX".</title>
  </head>
  <body>
    <div class="root">
        <h1>Привет, Кот. Мои ответы на теоретические вопросы за 30 неделю.</h1>
        <ol>
          <li>
            <span class="question">Какие есть общие особенности у React.Context и MobX?</span>
            <p>Ответ: React.Context и MobX - это две различные библиотеки для управления состоянием в React-приложениях. Вот несколько общих особенностей, которые у них есть:
                <ul>
                    <li>Управление состоянием: и React.Context, и MobX предназначены для управления состоянием в       React-приложениях. Они оба предоставляют механизмы для хранения и обновления состояния приложения.
                    </li>
                    <li>Возможность передачи данных через компоненты: и React.Context, и MobX позволяют передавать данные через компоненты дочерних уровней, без необходимости явно передавать их через пропсы.
                    </li>
                    <li>Реактивность: и React.Context, и MobX имеют подход к реактивности, что означает, что компоненты будут автоматически перерисовываться при изменении состояния. React.Context использует механизм "рендер-вызова" для обнаружения изменений, в то время как MobX использует "наблюдаемые объекты" для отслеживания зависимостей и автоматической перерисовки компонентов.
                    </li>
                    <li>Глобальное состояние: оба инструмента позволяют создавать и использовать глобальное состояние в приложении. React.Context позволяет создавать контекстные провайдеры и потребителей, которые оборачивают компоненты и предоставляют им доступ к общему состоянию. MobX предоставляет возможность создавать "наблюдаемые объекты", которые могут быть использованы централизованно в приложении.
                    </li>
                </ul>
            </p>
          </li>
          <li>
            <span class="question">Как можно структурировать наше приложение для работы с менеджерами состояний?</span>
            <p>Ответ: будет удобно работать, если мы разделим файлы по их назначению:
                – папка components, куда мы положим все компоненты;
                – папка stores, где будут содержаться данные, а также логика работы с ними.
                Например, типовой компонент для ввода данных у нас состоит из двух файлов:Input.js и InputStore.js. Первый файл — это «глупый» компонент React, отвечающий строго за отображение, второй — данные этого компонента, правила работы с пользователем (onClick, onChange, и т.д.).
            </p>
          </li>
          <li>
            <span class="question">Когда есть смысл подключать в приложение менеджеры состояний?</span>
            <p>Ответ: когда приложение большое и сложное. Менеджеры состояний позволят избежать большого количества шалблонного кода. Обеспечивают точность повторного рендеринга. Когда состояние приложения имеет сложную структуру или содержит вложенные данные, использование менеджера состояний помогает удерживать эти состояния в едином месте и обеспечивает удобный доступ к этим данным. Если несколько компонентов в вашем приложении используют одни и те же данные, использование менеджера состояний помогает сделать эти данные доступными для всех компонентов без необходимости передачи их через пропсы. Менеджеры состояний позволяют упростить тестирование за счет встроенных инструментов для тестирования.
            </p>
          </li>
          <li>
            <span class="question">Как вы думаете, почему нельзя использовать @observable вместе с методом shouldComponentUpdate?</span>
            <p>Ответ: При использовании MobX в React, @observable используется для отслеживания изменений в состоянии компонента. Когда состояние меняется, MobX автоматически обновляет компонент и перерисовывает его.<br> 
            С другой стороны, shouldComponentUpdate - это метод жизненного цикла React, который позволяет контролировать, должен ли компонент быть перерисован или нет. Этот метод возвращает булевое значение, указывающее, обновлять ли компонент.<br>
            Однако, использование @observable вместе с shouldComponentUpdate может привести к нежелательным последствиям. Например, MobX может не знать о том, что произошли изменения в компоненте, если shouldComponentUpdate вернет false и компонент не будет перерисован. Это может привести к несогласованности данных, если компонент полагается на актуальность @observable значений.
            </p>
          </li>
          <li>
            <span class="question">Можно ли использовать несколько разных store в одном приложении?</span>
            <p>Ответ: MobX позволяет создать несколько хранилищ (store) для разных частей приложения. 
            </p>
          </li>
          <li>
            <span class="question">Можно ли использовать MobX без декораторов?</span>
            <p>Ответ: Да, можно использовать MobX без декораторов. В качестве альтернативы можно использовать функциональный стиль оборачивания компонентов в `observer`. Вместо декораторов `@observable`, `@action`, и `@computed` можно использовать прямые вызовы методов `observable`, `action` и `computed`.
            </p>
          </li>
          <li>
            <span class="question">Можно ли использовать MobX без React?</span>
            <p>Ответ: MobX - это автономная библиотека для управления состоянием, которая не зависит от конкретной библиотеки для создания пользовательского интерфейса. 
            </p>
          </li>
        </ol>
  </body>
</html>
